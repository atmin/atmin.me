---
import type { GetStaticPaths } from 'astro';
import type { ImageMetadata } from 'astro';
import { getCollection } from 'astro:content';

export const getStaticPaths = (async () => {
    const panoramas = await getCollection('pano');
    return panoramas.map(({ id }) => ({ params: { id } }));
}) satisfies GetStaticPaths;

const emptyImage =
    'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';

const loRes = import.meta.glob<{ default: ImageMetadata }>(
    '/src/data/pano/**/8k.avif'
);
const loResSrc = (id: string) =>
    (loRes[`/src/data/pano/${id}/8k.avif`] ?? (() => emptyImage))();

const hiRes = import.meta.glob<{ default: ImageMetadata }>(
    '/src/data/pano/**/16k.avif'
);
const hiResSrc = (id: string) =>
    (hiRes[`/src/data/pano/${id}/16k.avif`] ?? (() => emptyImage))();

const { id } = Astro.params;

const src = (await loResSrc(id)).default.src;
---

<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Little Planet Viewer</title>
        <style>
            body {
                margin: 0;
                overflow: hidden;
            }
            canvas {
                display: block;
                width: 100vw;
                height: 100vh;
            }
        </style>
    </head>
    <body>
        <canvas id="glcanvas" data-src={src}></canvas>
        <script>
            const canvas = document.getElementById(
                'glcanvas'
            ) as HTMLCanvasElement;
            const gl = canvas.getContext('webgl');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const vertexShaderSource = `
      attribute vec2 position;
      attribute vec2 uv;
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = vec4(position, 0.0, 1.0);
      }
    `;

            const fragmentShaderSource = `
      precision mediump float;
      uniform sampler2D uTexture;
      uniform float uYaw;
      uniform float uPitch;
      varying vec2 vUv;

      void main() {
        vec2 ndc = (vUv - 0.5) * 2.0;
        float r2 = dot(ndc, ndc);
        float scale = 2.0 / (r2 + 1.0);
        vec3 dir = normalize(vec3(ndc * scale, scale - 1.0));

        float cy = cos(uYaw), sy = sin(uYaw);
        float cp = cos(uPitch), sp = sin(uPitch);

        mat3 rotY = mat3(cy, 0.0, -sy, 0.0, 1.0, 0.0, sy, 0.0, cy);
        mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cp, -sp, 0.0, sp, cp);

        dir = rotY * rotX * dir;

        float longitude = atan(dir.z, dir.x);
        float latitude = asin(clamp(dir.y, -1.0, 1.0));

        vec2 texUv = vec2(0.5 - longitude / (2.0 * 3.1415926535),
                          0.5 - latitude / 3.1415926535);

        gl_FragColor = texture2D(uTexture, texUv);
      }
    `;

            function createShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    throw new Error(gl.getShaderInfoLog(shader));
                }
                return shader;
            }

            function createProgram(vsSource, fsSource) {
                const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
                const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
                const program = gl.createProgram();
                gl.attachShader(program, vs);
                gl.attachShader(program, fs);
                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    throw new Error(gl.getProgramInfoLog(program));
                }
                return program;
            }

            const program = createProgram(
                vertexShaderSource,
                fragmentShaderSource
            );
            gl.useProgram(program);

            // Buffers
            const quadPositions = new Float32Array([
                -1, -1, 1, -1, -1, 1, 1, 1,
            ]);
            const quadUVs = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
            const indices = new Uint16Array([0, 1, 2, 2, 1, 3]);

            const posBuf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
            gl.bufferData(gl.ARRAY_BUFFER, quadPositions, gl.STATIC_DRAW);

            const uvBuf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, uvBuf);
            gl.bufferData(gl.ARRAY_BUFFER, quadUVs, gl.STATIC_DRAW);

            const idxBuf = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

            const positionLoc = gl.getAttribLocation(program, 'position');
            const uvLoc = gl.getAttribLocation(program, 'uv');

            // Texture loading
            const texture = gl.createTexture();
            const image = new Image();
            image.crossOrigin = '';
            image.src = canvas.dataset.src!; // 2:1 panorama
            image.onload = () => {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0,
                    gl.RGB,
                    gl.RGB,
                    gl.UNSIGNED_BYTE,
                    image
                );
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT); // wrap horizontally
                gl.texParameteri(
                    gl.TEXTURE_2D,
                    gl.TEXTURE_WRAP_T,
                    gl.CLAMP_TO_EDGE
                ); // vertical wrap is optional
                gl.texParameteri(
                    gl.TEXTURE_2D,
                    gl.TEXTURE_MIN_FILTER,
                    gl.LINEAR
                );
                gl.texParameteri(
                    gl.TEXTURE_2D,
                    gl.TEXTURE_MAG_FILTER,
                    gl.LINEAR
                );

                // gl.generateMipmap(gl.TEXTURE_2D);
                render();
            };

            // Uniforms
            const uYawLoc = gl.getUniformLocation(program, 'uYaw');
            const uPitchLoc = gl.getUniformLocation(program, 'uPitch');
            const uTextureLoc = gl.getUniformLocation(program, 'uTexture');

            let yaw = 0;
            let pitch = 0;

            // Mouse interaction
            let dragging = false,
                lastX = 0,
                lastY = 0;

            canvas.addEventListener('mousedown', (e) => {
                dragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!dragging) return;
                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;
                lastX = e.clientX;
                lastY = e.clientY;
                yaw += dx * 0.005;
                pitch += dy * 0.005;
                render();
            });

            canvas.addEventListener('mouseup', () => (dragging = false));
            canvas.addEventListener('mouseleave', () => (dragging = false));

            function render() {
                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                gl.useProgram(program);

                gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
                gl.enableVertexAttribArray(positionLoc);
                gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, uvBuf);
                gl.enableVertexAttribArray(uvLoc);
                gl.vertexAttribPointer(uvLoc, 2, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);

                gl.uniform1f(uYawLoc, yaw);
                gl.uniform1f(uPitchLoc, pitch);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.uniform1i(uTextureLoc, 0);

                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            }

            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                render();
            });
        </script>
    </body>
</html>
